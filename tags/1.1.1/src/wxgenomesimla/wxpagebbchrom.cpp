/////////////////////////////////////////////////////////////////////////////
// Name:        wxpagebbchrom.cpp
// Purpose:     
// Author:      Eric Torstenson
// Modified by: 
// Created:     Thu 06 Dec 2007 01:21:37 PM CST
// RCS-ID:      
// Copyright:   Copyright 2007 Ritchie Lab - See COPYING for License 
// Licence:     
/////////////////////////////////////////////////////////////////////////////

// Generated by DialogBlocks (Personal Edition), Thu 06 Dec 2007 01:21:37 PM CST

#if defined(__GNUG__) && !defined(__APPLE__)
#pragma implementation "wxpagebbchrom.h"
#endif

// For compilers that support precompilation, includes "wx/wx.h".
#include "wx/wxprec.h"

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
#include "wx/wx.h"
#endif

////@begin includes
////@end includes

#include <wx/notebook.h>
#include "wxpagebbchrom.h"

#include <iostream>

#include "img/LD-Plot.xpm"
#include "img/LD-PlotBW.xpm"


namespace GenomeSIM {

namespace GUI {

using namespace std;
////@begin XPM images
#include "img/LD-Plot.xpm"
#include "img/LD-PlotBW.xpm"
////@end XPM images

/*!
 * wxPageBBChrom type definition
 */

IMPLEMENT_DYNAMIC_CLASS( wxPageBBChrom, wxPanel )

/*!
 * wxPageBBChrom event table definition
 */

BEGIN_EVENT_TABLE( wxPageBBChrom, wxPanel )

////@begin wxPageBBChrom event table entries
    EVT_SIZE( wxPageBBChrom::OnSize )

    EVT_TEXT( ID_CHROM_LABEL, wxPageBBChrom::OnChromLabelUpdated )

    EVT_GRID_CELL_CHANGE( wxPageBBChrom::OnCellChange )
    EVT_GRID_EDITOR_HIDDEN( wxPageBBChrom::OnEditorHidden )
    EVT_GRID_CMD_EDITOR_HIDDEN( ID_GRID_BLOCKS, wxPageBBChrom::OnGridBlocksEditorHidden )

    EVT_SPINCTRL( ID_BLOCK_COUNTS, wxPageBBChrom::OnBlockCountsUpdated )

    EVT_MENU( ID_ADD_BLOCK, wxPageBBChrom::OnAddBlockClick )

    EVT_MENU( ID_REMOVE_BLOCK, wxPageBBChrom::OnRemoveBlockClick )

////@end wxPageBBChrom event table entries

END_EVENT_TABLE()

/*!
 * wxPageBBChrom constructors
 */

wxPageBBChrom::wxPageBBChrom( ) : pool(0, 2)
{
}

wxPageBBChrom::wxPageBBChrom( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style ) : pool(0,2)
{
    Create(parent, id, pos, size, style);
}

void wxPageBBChrom::InitLabel(const char *label, uint chromID) {
	pool.SetID(chromID);
	txtChromLabel->ChangeValue(wxT(label));
}

void wxPageBBChrom::RefreshSize() {

	if (gridBlocks) {
		int width, height;
		float widths[] = { 0.11, 0.11, 0.175, 0.175, 0.175, 0.175, 0.08 };
		gridBlocks->GetSize(&width, &height);
		width-=(gridBlocks->GetRowLabelSize() + 20);
	
		for (int i=0; i<7; i++) 
			gridBlocks->SetColSize(i, (uint)(widths[i] * width));
	}	
}

void wxPageBBChrom::InitList() {

	gridBlocks->ClearGrid();
	gridBlocks->CreateGrid(0, 7);
	guageCompletion->SetRange(100);

	gridBlocks->SetRowLabelSize(20);
	gridBlocks->SetColLabelSize(40);

	gridBlocks->SetColLabelValue(0, wxT("Min.\nSNPs"));
	gridBlocks->SetColFormatNumber(0);
	gridBlocks->SetColLabelValue(1, wxT("Max.\nSNPs"));
	gridBlocks->SetColFormatNumber(1);
	gridBlocks->SetColLabelValue(2, wxT("Min. Ext.\nMap Dist."));
	gridBlocks->SetColFormatFloat(2, 8, 10);
	gridBlocks->SetColLabelValue(3, wxT("Max. Ext.\nMap Dist."));
	gridBlocks->SetColFormatFloat(3, 8, 10);
	gridBlocks->SetColLabelValue(4, wxT("Min. Int.\nMap Dist."));
	gridBlocks->SetColFormatFloat(4, 8, 10);
	gridBlocks->SetColLabelValue(5, wxT("Max. Int.\nMap Dist."));
	gridBlocks->SetColFormatFloat(5, 8, 10);
	gridBlocks->SetColLabelValue(6, wxT("Weight"));
	gridBlocks->SetColFormatFloat(6, 5, 2);

	gridBlocks->Fit();

//	list->Show();
	RefreshSize();
	
}

void wxPageBBChrom::SetLabel(const char *label) {
	txtChromLabel->SetValue(wxT(label));
	UpdateLabel(label);
}

void wxPageBBChrom::Commit() {
	uint blockCount = gridBlocks->GetNumberRows();
	chromosome->ClearBlocks();

	cout<<"wxPageBBChrom::Commit()\n";

	chromosome->SetBlockCount(rangeBlockCounts->GetValue());

	for (uint i=0; i<blockCount; i++) {
		chromosome->DefineBlock(
			ToInt(gridBlocks->GetCellValue(i, 0)), 
			ToInt(gridBlocks->GetCellValue(i, 1)),
			ToDouble(gridBlocks->GetCellValue(i, 2)),
			ToDouble(gridBlocks->GetCellValue(i, 3)),
			ToDouble(gridBlocks->GetCellValue(i, 4)),
			ToDouble(gridBlocks->GetCellValue(i, 5)),
			ToDouble(gridBlocks->GetCellValue(i, 6)));
	}
		
}


void wxPageBBChrom::AddBlock(ChromPool::BlockDefinition &block) {
	long idx = gridBlocks->GetNumberRows();
	gridBlocks->AppendRows(1);

	if (idx >= 0) {
		wxString val;
		val.Printf(_("%d"), block.minSnpCount);
		gridBlocks->SetCellValue(idx, 0, val);
		
		val.Printf(_("%d"), block.maxSnpCount);
		gridBlocks->SetCellValue(idx, 1, val);

		val.Printf(_("%.10f"), block.minBlckMap);
		gridBlocks->SetCellValue(idx, 2, val);
	
		val.Printf(_("%.10f"), block.maxBlckMap);
		gridBlocks->SetCellValue(idx, 3, val);

		val.Printf(_("%.10f"), block.minSnpMap);
		gridBlocks->SetCellValue(idx, 4, val);

		val.Printf(_("%.10f"), block.maxSnpMap);
		gridBlocks->SetCellValue(idx, 5, val);

		val.Printf(_("%.2f"), block.frequency);
		gridBlocks->SetCellValue(idx, 6, val);
	}


	UpdateCompletionMonitor();
	
}
void wxPageBBChrom::AddNewBlock() {
	ChromPool::BlockDefinition block;
	block.Randomize();
	AddBlock(block);

	UpdateCompletionMonitor();
}

void wxPageBBChrom::UpdateCompletionMonitor() {
	static bool hasWarnedAboutExceeding = false;
	int blockCount = gridBlocks->GetNumberRows();
	float sum = 0.0;
	double fVal;

	for (int i=0; i<blockCount; i++) {
		if (gridBlocks->GetCellValue(i, 6).ToDouble(&fVal))
			sum+=fVal;
	}
	int totalPoints = (int)(sum*100);
	wxString lbl;
	lbl.Printf("%d%%", totalPoints);
	txtPercentComplete->SetLabel(lbl);
	if (totalPoints > 100) {
		cout<<"Sum has grown past 1.0\n";
		totalPoints = 100;

		if (!hasWarnedAboutExceeding) {
			wxMessageDialog dlg(NULL, wxT("The sum all block weights exceeds 1.0. This means that some blocks will not get selected with the weight that have been assigned. To ensure that each block is treated exactly as expected, make sure all weights sum to 1.0. If the sum is less than 1.0, the default block is used for the remainder."), wxT("Too many blocks"), wxOK);		
			dlg.ShowModal();
			hasWarnedAboutExceeding = true;
		}
	}
	
	guageCompletion->SetValue(totalPoints);
	
}	
/*!
 * wxPageBBChrom creator
 */

bool wxPageBBChrom::Create( wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style )
{
////@begin wxPageBBChrom member initialisation
    txtChromLabel = NULL;
    gridBlocks = NULL;
    rangeBlockCounts = NULL;
    guageCompletion = NULL;
    txtPercentComplete = NULL;
////@end wxPageBBChrom member initialisation

////@begin wxPageBBChrom creation
    wxPanel::Create( parent, id, pos, size, style );

    CreateControls();
    if (GetSizer())
    {
        GetSizer()->SetSizeHints(this);
    }
    Centre();
////@end wxPageBBChrom creation
    return TRUE;
}

/*!
 * Control creation for wxPageBBChrom
 */

void wxPageBBChrom::CreateControls()
{    
////@begin wxPageBBChrom content construction
    wxPageBBChrom* itemPanel1 = this;

    wxBoxSizer* itemBoxSizer2 = new wxBoxSizer(wxVERTICAL);
    itemPanel1->SetSizer(itemBoxSizer2);

    wxBoxSizer* itemBoxSizer3 = new wxBoxSizer(wxVERTICAL);
    itemBoxSizer2->Add(itemBoxSizer3, 1, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer4 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer3->Add(itemBoxSizer4, 0, wxGROW|wxALL, 5);

    wxBoxSizer* itemBoxSizer5 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer4->Add(itemBoxSizer5, 1, wxGROW|wxALL, 5);

    wxStaticText* itemStaticText6 = new wxStaticText( itemPanel1, wxID_STATIC, _("Chromosome Label:"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer5->Add(itemStaticText6, 0, wxALIGN_CENTER_VERTICAL|wxALL|wxADJUST_MINSIZE, 5);

    txtChromLabel = new wxTextCtrl( itemPanel1, ID_CHROM_LABEL, _T(""), wxDefaultPosition, wxSize(250, -1), 0, wxTextValidator(wxFILTER_ALPHANUMERIC) );
    if (wxPageBBChrom::ShowToolTips())
        txtChromLabel->SetToolTip(_("Set the label for this chromosome. The label is used for filenames as well as identification on various reports."));
    itemBoxSizer5->Add(txtChromLabel, 1, wxGROW|wxALL, 5);

    wxStaticBox* itemStaticBoxSizer8Static = new wxStaticBox(itemPanel1, wxID_ANY, _("Available Blocks:"));
    wxStaticBoxSizer* itemStaticBoxSizer8 = new wxStaticBoxSizer(itemStaticBoxSizer8Static, wxVERTICAL);
    itemBoxSizer3->Add(itemStaticBoxSizer8, 1, wxGROW|wxALL, 0);

    gridBlocks = new wxGrid( itemPanel1, ID_GRID_BLOCKS, wxDefaultPosition, wxSize(200, 75), wxSUNKEN_BORDER|wxVSCROLL );
    if (wxPageBBChrom::ShowToolTips())
        gridBlocks->SetToolTip(_("Add Blocks and Edit them as required"));
    gridBlocks->SetFont(wxFont(8, wxSWISS, wxNORMAL, wxNORMAL, false, wxT("Sans")));
    gridBlocks->SetDefaultColSize(50);
    gridBlocks->SetDefaultRowSize(20);
    gridBlocks->SetColLabelSize(25);
    gridBlocks->SetRowLabelSize(0);
    itemStaticBoxSizer8->Add(gridBlocks, 1, wxGROW|wxALL, 0);

    wxBoxSizer* itemBoxSizer10 = new wxBoxSizer(wxHORIZONTAL);
    itemStaticBoxSizer8->Add(itemBoxSizer10, 0, wxGROW|wxALL, 0);

    wxBoxSizer* itemBoxSizer11 = new wxBoxSizer(wxHORIZONTAL);
    itemBoxSizer10->Add(itemBoxSizer11, 1, wxGROW|wxALL, 5);

    wxStaticText* itemStaticText12 = new wxStaticText( itemPanel1, wxID_STATIC, _("Block Count:"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer11->Add(itemStaticText12, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    rangeBlockCounts = new wxSpinCtrl( itemPanel1, ID_BLOCK_COUNTS, _T("15"), wxDefaultPosition, wxDefaultSize, wxSP_ARROW_KEYS, 1, 10000, 15 );
    itemBoxSizer11->Add(rangeBlockCounts, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    guageCompletion = new wxGauge( itemPanel1, ID_GAUGE_COMPLETION, 100, wxDefaultPosition, wxSize(-1, 10), wxGA_HORIZONTAL );
    guageCompletion->SetValue(0);
    guageCompletion->SetForegroundColour(wxColour(165, 42, 42));
    itemBoxSizer11->Add(guageCompletion, 1, wxGROW|wxALL, 10);

    txtPercentComplete = new wxStaticText( itemPanel1, wxID_STATIC, _("0%"), wxDefaultPosition, wxDefaultSize, 0 );
    itemBoxSizer11->Add(txtPercentComplete, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    itemBoxSizer10->Add(75, 5, 0, wxALIGN_CENTER_VERTICAL|wxALL, 5);

    wxToolBar* itemToolBar17 = new wxToolBar( itemPanel1, wxID_ANY, wxDefaultPosition, wxSize(-1, 30), wxTB_FLAT|wxNO_BORDER );
    itemToolBar17->SetBackgroundColour(wxColour(255, 255, 255));
    itemToolBar17->SetFont(wxFont(6, wxDEFAULT, wxNORMAL, wxNORMAL, false, wxT("Sans")));
    itemToolBar17->SetToolPacking(2);
    itemToolBar17->SetToolBitmapSize(wxSize(16, 16));
    wxBitmap itemtool18Bitmap(itemPanel1->GetBitmapResource(wxT("img/LD-Plot.xpm")));
    wxBitmap itemtool18BitmapDisabled;
    itemToolBar17->AddTool(ID_ADD_BLOCK, _("Add Block"), itemtool18Bitmap, itemtool18BitmapDisabled, wxITEM_NORMAL, _("Add a new block to the avable block list"), wxEmptyString);
    itemToolBar17->AddSeparator();
    wxBitmap itemtool20Bitmap(itemPanel1->GetBitmapResource(wxT("img/LD-PlotBW.xpm")));
    wxBitmap itemtool20BitmapDisabled;
    itemToolBar17->AddTool(ID_REMOVE_BLOCK, _("Remove"), itemtool20Bitmap, itemtool20BitmapDisabled, wxITEM_NORMAL, _("Delete the block"), wxEmptyString);
    itemToolBar17->Realize();
    itemBoxSizer10->Add(itemToolBar17, 0, wxALIGN_CENTER_VERTICAL|wxALL, 0);

////@end wxPageBBChrom content construction
	InitList();


}

/*!
 * Should we show tooltips?
 */

bool wxPageBBChrom::ShowToolTips()
{
    return TRUE;
}

/*!
 * Get bitmap resources
 */

wxBitmap wxPageBBChrom::GetBitmapResource( const wxString& name )
{

    // Bitmap retrieval
    if (name == wxT("img/LD-Plot.xpm"))
    {
        wxBitmap bitmap(LD_Plot_xpm);
        return bitmap;
    }
    else if (name == wxT("img/LD-PlotBW.xpm"))
    {
        wxBitmap bitmap(LD_PlotBW_xpm);
        return bitmap;
    }
    return wxNullBitmap;

}

/*!
 * Get icon resources
 */

wxIcon wxPageBBChrom::GetIconResource( const wxString& name )
{
    // Icon retrieval
////@begin wxPageBBChrom icon retrieval
    wxUnusedVar(name);
    return wxNullIcon;
////@end wxPageBBChrom icon retrieval
}
/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_ADD_BLOCK
 */

void wxPageBBChrom::OnAddBlockClick( wxCommandEvent& event )
{
	AddNewBlock();
	event.Skip();
}


void wxPageBBChrom::DeleteRow(int row, int count) {
	gridBlocks->DeleteRows(row, count, true);
	UpdateCompletionMonitor();
}

/*!
 * wxEVT_COMMAND_MENU_SELECTED event handler for ID_REMOVE_BLOCK
 */

void wxPageBBChrom::OnRemoveBlockClick( wxCommandEvent& event )
{
	wxArrayInt rows = gridBlocks->GetSelectedRows();
	size_t count = rows.Count();
	for (size_t i=0; i<count; i++) 
		DeleteRow(rows.Item(i), 1);

}


/*!
 * wxEVT_COMMAND_TEXT_UPDATED event handler for ID_CHROM_LABEL
 */

void wxPageBBChrom::OnChromLabelUpdated( wxCommandEvent& event )
{
	wxNotebook* mommy = (wxNotebook*)GetParent();
	if (mommy && txtChromLabel) 
		mommy->SetPageText(mommy->GetSelection(), txtChromLabel->GetLineText(0));
}



/*!
 * wxEVT_SIZE event handler for ID_DIALOG
 */

void wxPageBBChrom::OnSize( wxSizeEvent& event )
{	
	RefreshSize();
	event.Skip();
}



/*!
 * wxEVT_GRID_CELL_CHANGE event handler for ID_GRID_BLOCKS
 */

void wxPageBBChrom::OnCellChange( wxGridEvent& event )
{
	int col = event.GetCol();
	if (col == 6) 
		UpdateCompletionMonitor();
////@begin wxEVT_GRID_CELL_CHANGE event handler for ID_GRID_BLOCKS in wxPageBBChrom.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_GRID_CELL_CHANGE event handler for ID_GRID_BLOCKS in wxPageBBChrom. 
}


/*!
 * wxEVT_GRID_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS
 */

void wxPageBBChrom::OnEditorHidden( wxGridEvent& event )
{
	int col = event.GetCol();
	if (col == 6) 
		UpdateCompletionMonitor();

////@begin wxEVT_GRID_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS in wxPageBBChrom.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_GRID_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS in wxPageBBChrom. 
}


/*!
 * wxEVT_GRID_CMD_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS
 */

void wxPageBBChrom::OnGridBlocksEditorHidden( wxGridEvent& event )
{
	int col = event.GetCol();
	if (col == 6) 
		UpdateCompletionMonitor();

////@begin wxEVT_GRID_CMD_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS in wxPageBBChrom.
    // Before editing this code, remove the block markers.
    event.Skip();
////@end wxEVT_GRID_CMD_EDITOR_HIDDEN event handler for ID_GRID_BLOCKS in wxPageBBChrom. 
}

void wxPageBBChrom::WriteMarkerInfo(const char *filename) {
	ofstream file(filename);
	pool.SaveLoci(file, 0.0);
}


vector<Locus> wxPageBBChrom::RealizeChromosome(ChromPool::BlockDefinition& block) {
	pool.ClearBlocks();
	pool.Clear();
	pool.ClearLoci();
	pool.DefineDefaultBlock(block);

	int blockCount = gridBlocks->GetNumberRows();
	
	for (int i=0; i<blockCount; i++) {
		ChromPool::BlockDefinition newBlock;
		long minSnpCount, maxSnpCount;
		gridBlocks->GetCellValue(i, 0).ToLong(&minSnpCount);
		gridBlocks->GetCellValue(i, 1).ToLong(&maxSnpCount);

		double minBlckRecomb, maxBlckRecomb, minSnpRecomb, maxSnpRecomb, freq;
		gridBlocks->GetCellValue(i, 2).ToDouble(&minBlckRecomb);
		gridBlocks->GetCellValue(i, 3).ToDouble(&maxBlckRecomb);
		gridBlocks->GetCellValue(i, 4).ToDouble(&minSnpRecomb);
		gridBlocks->GetCellValue(i, 5).ToDouble(&maxSnpRecomb);
		gridBlocks->GetCellValue(i, 6).ToDouble(&freq);
//		try {
			pool.DefineBlock(minSnpCount, maxSnpCount, minBlckRecomb, maxBlckRecomb, minSnpRecomb, maxSnpRecomb, freq);
//		} catch (Exception::General& e){ 
//			wxMessageBox(_(e.GetErrorMessage().c_str()));
//		}
	}
	
	LocusMap locusMap;
	pool.SetBlockCount(rangeBlockCounts->GetValue());

	pool.InitLoci(0, locusMap);	
	return pool.GetLoci();
	
}


/*!
 * wxEVT_COMMAND_SPINCTRL_UPDATED event handler for ID_SPINCTRL1
 */

void wxPageBBChrom::OnBlockCountsUpdated( wxSpinEvent& event )
{
	if (rangeBlockCounts)
		pool.SetBlockCount(rangeBlockCounts->GetValue());
}

}

}





