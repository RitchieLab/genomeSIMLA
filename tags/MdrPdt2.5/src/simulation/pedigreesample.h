//
// C++ Interface: pedigreesample
//
// Description: 
//
//
// Author: Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>, (C) 2007
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef SIMULATIONPEDIGREESAMPLE_H
#define SIMULATIONPEDIGREESAMPLE_H
#include "utility/types.h"
#include "basicsample.h"


namespace Simulation {

/**
 * @brief provides necessary control over generation of pedigree samples
 * Pedigrees are generated by drawing two individuals, Paternal and Maternal individuals
 * In order to produce offspring, we produce an array of chromosomes based on crossing their two sets of chromosomes
 * and then create the child. 

	@author Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>
*/
class PedigreeSample : public Sample {
public:
	/**
	 * @brief Construction
	 * @param affectedSibs How many siblings must be affected to make it into the dataset
	 * @param unaffectedSibs How many siblings must be unaffected to make it into the dataset
	 * @param extraChildren Extra children used to increase the likelihood of matching the required status counts
	 */
    PedigreeSample(uint affectedSibs, uint unaffectedSibs, float genotypeError, float phenoError, 
		float missingData, uint extraChildren = 2);

    virtual ~PedigreeSample();

	/**
	 * @brief Constructs a population based on the genetic data in pools with status derived from a 
	 * model provided by models.
	 * @param pools Array of chromosome pools. Each pool contains genetic data to be used to create a single individual
	 * @param chromCount Size of the array above
	 * @param models is used to randomly assign status
	 * @param individualCount Size of the resulting collection of individuals
	 */
	virtual void BuildSample(PoolManager &pools, ModelManager& models, uint individualCount);

	/**
	 * @brief Adds individuals to the local sample based on the model passed
	 * @param pools Array of gene pools
	 * @param chromCount Size of the array above
	 * @param model the model used to apply status
	 * @param individualCount the number of individuals to be used
	 */
	virtual void BuildSample(PoolManager &pools, PenetranceModel* model, uint familyCount);		


	/**
	 * @brief Apply phenocopy error 
	 */
	virtual void ApplyPhenocopyError(PoolManager *pools, uint familyCount);

	/**
	 * Resets the pedigree id back to 1
	 */
	void ResetPedID();

	/**
	 * @brief Resets the local data back to a starting point (for starting a new sample)
	 */
	virtual void Reset();

	/**
	 * @brief Returns a simple segment used for generating file names. This will be something like: 15-85.cc for 15% affected case/control. The application is still required to generate the rest of the filename, however
	 */
	virtual string GetDescriptor();

	/**
	 * @brief Dump the contents of the sample population to the stream
	 * @param os The stream to which the sample will be written
	 */
	virtual int WriteDataset(ostream &os, uint *gtCount);

	/**
	 * @brief Writes the parents of the pedigrees to a file in phased format. 
	 * @param os The stream to which the sample will be written
	 */
	virtual void WritePhased(ostream &os);
	void GenerateReport(ostream &os, uint padding);

protected:
	/**
	 * Draws an individual (grabbing each part from the various blocks)
	 */
	void DrawIndividual(PoolManager &pools, Individual &person);

	/**
	 * Removes the individual restriction from the pools. Used in the case of an inidivual not being used
	 */
	void ReturnIndividual(PoolManager &pools, Individual &person);


	uint affectedSibCount;							///<Used in determining what a valid pedigree is
	uint unaffectedSibCount;						///<Used to determine what a valid pedigree is
	uint extraSibs;									///<Extra sibs are drawn to increase likelihood of finding a valid pedigree. Only the desired numbers make their way into the file
	uint pedID;										
	vector<uint> familyStartPositions;				///<This is used to keep up with where each pedigree starts in order to allow shuffling families
};


class PedigreeMixedSample : public PedigreeSample {
public:
	PedigreeMixedSample(uint maxChildren, float gtErr, float phErr, float missing);
	~PedigreeMixedSample() {}

	/**
	 * @brief Adds individuals to the local sample based on the model passed
	 * @param pools Array of gene pools
	 * @param chromCount Size of the array above
	 * @param model the model used to apply status
	 * @param individualCount the number of individuals to be used
	 */
	virtual void BuildSample(PoolManager &pools, PenetranceModel* model, uint familyCount);		

};

inline
PedigreeMixedSample::PedigreeMixedSample(uint maxChildren, float gtErr, float phErr, float missing) : PedigreeSample(0,0,gtErr, phErr, missing, maxChildren) { }


inline
void PedigreeSample::Reset() {
	pedID=0;
	people.clear();
}

inline
string PedigreeSample::GetDescriptor() {
	stringstream ss;
	ss << "-";
	for (uint i=0; i<affectedSibCount; i++) 
		ss<<"A";
	for (uint i=0; i<unaffectedSibCount; i++) 
		ss<<"U";
	ss<<".ped";
	return ss.str();
}
}
#endif
