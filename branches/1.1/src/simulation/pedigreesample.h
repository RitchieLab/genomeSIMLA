//
// C++ Interface: pedigreesample
//
// Description: 
//
//
// Author: Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>, (C) 2007
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef SIMULATIONPEDIGREESAMPLE_H
#define SIMULATIONPEDIGREESAMPLE_H
#include "utility/types.h"
#include "basicsample.h"
#include "poolmanager.h"

namespace Simulation {



/**
 * @brief provides necessary control over generation of pedigree samples
 * Pedigrees are generated by drawing two individuals, Paternal and Maternal individuals
 * In order to produce offspring, we produce an array of chromosomes based on crossing their two sets of chromosomes
 * and then create the child. 

	@author Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>
*/
class PedigreeSample : public Sample {
public:
	struct FamilyPositionNode {
		uint start; 			///<The first index for a family	
		uint count;				///<The number of individuals for the family
		uint affecteds;			///<The number of affected individuals
		uint unaffecteds;		///<The number of unaffected individuals
		uint phenocopies;		///<The number of phenocopies
		FamilyPositionNode(uint s, uint c, uint a, uint u) : start(s), count(c), affecteds(a), unaffecteds(u), phenocopies(0) {}			
	};
	struct FamilyMakeup {
	public:
		FamilyMakeup(uint aff, uint unaff, uint count, uint extras=2) : familyCount(count), affectedSibCount(aff), unaffectedSibCount(unaff), extraSibs(extras) { }
		~FamilyMakeup() {}
		
		uint GetTotalChildren() { return affectedSibCount + unaffectedSibCount + extraSibs; }
		uint GetFamilyCount() { return familyCount; }
		uint AffectedSibs() { return affectedSibCount; }
		uint UnaffectedSibs() { return unaffectedSibCount; }
		uint ExtraSibs() { return extraSibs; }
		string GetConfigurationDetails() {
			stringstream ss;
			ss<<"DATASET FAMTYPE "<<affectedSibCount<<" "<<unaffectedSibCount<<" "
				<<extraSibs<<" "<<familyCount;
			return ss.str();
		}
		
		void ResetPedigrees() { pedigrees.clear(); }
		void AddPedigree(uint ped) { pedigrees.push_back(ped);}
		vector<uint>& GetPedigreeIDs() { return pedigrees; }
	protected:
		uint familyCount;								///<Indicate how many of this type there should be
		uint affectedSibCount;							///<Used in determining what a valid pedigree is
		uint unaffectedSibCount;						///<Used to determine what a valid pedigree is
		uint extraSibs;									///<Extra sibs are drawn to increase likelihood of finding a valid pedigree. Only the desired numbers make their way into the file
		vector<uint> pedigrees;							///<Array of pedigrees of this family type
	};
	

	/**
	 * @brief Construction
	 * @param affectedSibs How many siblings must be affected to make it into the dataset
	 * @param unaffectedSibs How many siblings must be unaffected to make it into the dataset
	 * @param extraChildren Extra children used to increase the likelihood of matching the required status counts
	 */
//    PedigreeSample(uint affectedSibs, uint unaffectedSibs, float genotypeError, float phenoError, 
	PedigreeSample(float gtError, float phError, float missingData, const char *desc);

	void AddFamilyType(uint aff, uint unaff, uint count, uint extras=2);

    virtual ~PedigreeSample();

	/**
	 * @brief Constructs a population based on the genetic data in pools with status derived from a 
	 * model provided by models.
	 * @param pools Array of chromosome pools. Each pool contains genetic data to be used to create a single individual
	 * @param model The penetrance model to be used
	 */
	virtual void BuildSample(PoolManager &pools, PenetranceModel *model);

	/**
	 * @brief Adds individuals to the local sample based on the model passed
	 * @param pools Array of chromosome pools. Each pool contains genetic data to be used to create a single individual
	 * @param model The penetrance model to be used
	 * @param fam The family makeup to be used
	 */
	virtual void BuildSample(PoolManager &pools, PenetranceModel* model, FamilyMakeup &fam);		


	/**
	 * @brief Apply phenocopy error 
	 */
	virtual void ApplyPhenocopyError(PoolManager *pools, PenetranceModel* model);
//	virtual void ApplyPhenocopyError(PoolManager *pools, FamilyMakeup& fam, PenetranceModel* model);

	/**
	 * Resets the pedigree id back to 1
	 */
	void ResetPedID();

	void LoadBinarySample(ifstream *genotypes, ifstream *meta, uint peopleCount, uint chromCount, vector<uint> &chrID);

	/**
	 * @brief Resets the local data back to a starting point (for starting a new sample)
	 */
	virtual void Reset();

	/**
	 * @brief Returns a simple segment used for generating file names. This will be something like: 15-85.cc for 15% affected case/control. The application is still required to generate the rest of the filename, however
	 */
	virtual string GetDescriptor();

	string GetType() { return "PED"; }

	string GetSummary();

	string GetDetails();
	
	string GetLabel() { return description; }

	virtual string Details();

	virtual bool UsesMeta() { return true; }

	/**
	 * @brief Dump the contents of the sample population to the stream
	 * @param os The stream to which the sample will be written
	 */
	virtual int WriteDataset(ostream &os, uint *gtCount, FamilyMakeup& fam);
	virtual int WriteDataset(ostream &os, uint *gtCount);
	virtual int WriteBinaryDataset(ostream &meta, ostream &genotypes);
	virtual int WriteBinaryDataset(ostream &meta, ostream &genotypes, FamilyMakeup& fam);
	/**
	 * @brief Write out the map file
	 * @param projectName the first part of the filename. We'll just be adding an extension
	 * @param pools The source of the various locus components
	 */
	void WriteSnpDetails(const char *projectName, PoolManager *pools);

	int WriteDataset(const char *filename, uint *gtCount);
//	virtual int LoadBinaryDataset(ostream &metadata, ostream &genotypes);
	/**
	 * @brief Writes the parents of the pedigrees to a file in phased format. 
	 * @param os The stream to which the sample will be written
	 */
	//virtual void WritePhased(ostream &os);

	/**
	 * @brief Writes the marker info data to the stream (this will represent all snp information associated with a single data sample)
	 * @param os The stream to which the marker information is written
	 */
//	virtual void GenerateLDMap(ostream &os);

	void GenerateReport(ostream &os, uint padding);
	static bool UseOriginalCross;
	std::vector<Individual*>* BuildPedigree(PoolManager *pools, PenetranceModel* model, uint pedID, uint affected, uint unaffected, int extra);
protected:
	/**
	 * Draws an individual (grabbing each part from the various blocks)
	 */
//	void DrawIndividual(PoolManager &pools, Individual &person);

	/**
	 * Removes the individual restriction from the pools. Used in the case of an inidivual not being used
	 */
	void ReserveIndividual(PoolManager &pools, Individual &person);

	void ApplyPresentGenotypes(PoolManager &pools, Individual &person);

	uint pedID;										
	vector<FamilyPositionNode> familyStartPositions;				///<This is used to keep up with where each pedigree starts in order to allow shuffling families
	vector<FamilyMakeup> familyTypes;
	uint familyCount;
	string description;
	uint affectedChildren;				///<total number of affected children in the dataset
	
};


class PedigreeMixedSample : public PedigreeSample {
public:
	PedigreeMixedSample(uint maxChildren, float gtErr, float phErr, float missing, const char *desc);
	~PedigreeMixedSample() {}

	/**
	 * @brief Adds individuals to the local sample based on the model passed
	 * @param pools Array of gene pools
	 * @param chromCount Size of the array above
	 * @param model the model used to apply status
	 * @param individualCount the number of individuals to be used
	 */
	virtual void BuildSample(PoolManager &pools, PenetranceModel* model);		

	string Details();
protected:
	uint maxChildren;
};
class PedigreeContinuousSample: public PedigreeSample {
public:
	PedigreeContinuousSample(float gtErr, float phErr, float missing, const char *desc);
	void BuildSample(PoolManager &pools, PenetranceModel *model, FamilyMakeup& family);
	int WriteDataset(ostream &os, uint *gtCount);
	int WriteDataset(ostream &os, uint *gtCount, FamilyMakeup& fam);
	int WriteBinaryDataset(ostream &meta, ostream &genotypes, FamilyMakeup& fam);
	int WriteBinaryDataset(ostream &meta, ostream &genotypes);
	void ApplyPhenocopyError(PoolManager *pools, PenetranceModel* model);
	void ApplyPhenocopyError(PoolManager *pools, FamilyMakeup& fam, PenetranceModel* model);
	bool Verify(PenetranceModel* model);
	void AppendGenotypeCountsToReport(StatusModel::ModelLociArray loci);
	void ReportGenotypeCounts(vector<StatusModel::DiseaseLocus> loci, ostream& output);
	void WriteDatFile(PoolManager *pools, ostream& os);
	/**
	 * @brief Write out the dat file
	 * @param projectName the first part of the filename. We'll just be adding an extension
	 * @param pools The source of the various locus components
	 */
	void WriteSnpDetails(const char *projectName, PoolManager *pools);

};

inline
PedigreeContinuousSample::PedigreeContinuousSample(float gtErr, float phErr, float missing, const char *desc) : 				PedigreeSample(gtErr, phErr, missing, desc) { 
}

inline
PedigreeMixedSample::PedigreeMixedSample(uint maxChildren, float gtErr, float phErr, float missing, const char *desc) : 				PedigreeSample(gtErr, phErr, missing, desc) { 
//	AddFamilyType(0,0,count,maxChildren);
}


inline
void PedigreeSample::Reset() {
	pedID=0;
	people.clear();
}

inline
string PedigreeSample::GetDescriptor() {
	stringstream ss;
	ss << "-" << description;
/*	for (uint i=0; i<affectedSibCount; i++) 
		ss<<"A";
	for (uint i=0; i<unaffectedSibCount; i++) 
		ss<<"U";*/
	ss<<".ped";
	return ss.str();
}

inline
string PedigreeSample::Details() {
	return string("Pedigree Sample: ") + description;
}

inline
string PedigreeMixedSample::Details() {
	return string("Mixed Pedigree Sample: ") + description;
}

}
#endif
