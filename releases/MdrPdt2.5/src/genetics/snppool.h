//
// C++ Interface: snppool
//
// Description: 
//
//
// Author: Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>, (C) 2006
//
// Copyright: See COPYING file that comes with this distribution
//
//
#ifndef GENETICSSNPPOOL_H
#define GENETICSSNPPOOL_H

#include <vector>
#include <map>
#include "snpaligned.h"
//#include <boost/thread/mutex.hpp>

namespace Genetics {

using namespace std;

typedef vector<SnpAligned*> SnpVector ;
typedef map<uint, SnpAligned*> SnpMap;
typedef pair<uint, SnpAligned*> SnpMapPair;
#define MAX_EXPECTED_GENOTYPECOUNT 64
/**
	@brief Provide a way to maintain a pool of snps in order to avoid "new"ing them repeatedly. 

	@author Eric Torstenson <torstenson@chgr.mc.vanderbilt.edu>
*/
class SnpPool {
public:
	
	/**
	 * @brief Provide the pool with the basics it needs for setting up the pool.
	 * If the avaialable pool is empty, it will allocate growby items.
	 * @param cachesize Indicates the initial size of the object cache
	 * @param growby Indicates how many more objects will be added to the cache when the
	 * @param defGenotypeCount The default count of individual genetypes
	 * available pool is empty
	 */
	static void Initialize(uint cachesize, uint growby, uint defGenotypeCount);

	/**
	 * @brief Attempts to release some of the excess that has been generated by use.
	 * If the available pool is greater than 150% of the cachesize, it will remove the excess
	 */
	void Reduce();

	/**
	 * @brief Singleton interface for acquiring a copy of the pool
	 */
	static SnpPool *Instance();

	/**
	 * @brief Acknowledgement when the instance is no longer needed
	 */
	static void Release();

	/**
	 * @brief Acquire a snp from the pool. 
	 * @param genotypeCount The number of genetypes anticipated
	 * @return A reference to a new(ish) Snp
	 * @note It is important to note that this doesn't do any reference counting nor
	 * garbage collection. You ask for it, you MUST release it when you are finished!
	 */
	SnpAligned *GetSnp(uint genotypeCount, uint indCount = 0);

	/**
	 * @brief Indicate that the snp is no longer required. 
	 * Once a  snp is no longer needed, it will be moved into the
	 * available pool and can be used later.
	 * @param snp The SNP that is no longer needed
	 * @note This assumes you know what you are doing. Releasing back into the pool is
	 * Effectively the same as a delete, except the pool will let it linger for a bit longer
	 * in case someone else needs it.
	 */
	void ReleaseSnp(SnpAligned *snp);

	/**
	 * @brief Simple function to return the size of the available SNPs in the pool
	 */
	int GetUnusedCount();

	/**
	 * @brief Returns the number of snps currently in use
	 */
	int GetUsedCount();

	void Purge();
protected:	
	static uint _instanceCount;							///<The number of instances in use
	static SnpPool *_instance;							///<The one instance of the pool

	static uint cachesize;								///<The size of the original pool
	static uint growby;									///<The number of new items to add when the available pool is empty
	static uint defGenotypeCount;						///<This is the number of genotypes most of the SNPs are expected to have
	static uint snpID;									///<Number used to id a snp

    SnpPool();
    ~SnpPool();

	void ResizeAvailable(uint count);					///<Ensure that the available cache is of size, count	

	SnpMap snpsInUse;									///<The pool of snps currently in use
	SnpVector snpsAvailable;							///<The pool of snps that can be acquired
	SnpAligned *lastSnp[MAX_EXPECTED_GENOTYPECOUNT];	///<to speed up uses where we get and release over and over

	//boost::mutex poolMutex;								///<Guarantees that we aren't going to have more than one thread using the pool
};

inline
int SnpPool::GetUnusedCount() {
	return snpsAvailable.size();
}

inline
int SnpPool::GetUsedCount() {
	return snpsInUse.size();
}

inline
void SnpPool::Initialize(uint cache, uint growth, uint count=3) 	{
	cachesize=cache;
	growby=growth;
	defGenotypeCount=count;
}

inline
SnpPool *SnpPool::Instance() {
	if (_instance == NULL)	{
		_instance = new SnpPool();
		_instance->ResizeAvailable(cachesize);
		_instanceCount = 0;
	}
	_instanceCount++;
	return _instance;
}

inline
void SnpPool::Release() {
	if (--_instanceCount <= 0)	{
		delete _instance;
		_instance = NULL;
	}
}

inline
SnpPool::SnpPool() {
	for (uint i =0; i<MAX_EXPECTED_GENOTYPECOUNT; i++) 
		lastSnp[i]=NULL;
}



}
#endif
